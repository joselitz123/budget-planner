// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: sharing.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const checkBudgetAccess = `-- name: CheckBudgetAccess :one
SELECT 'owner' as permission, true as is_owner
FROM budgets b
WHERE b.id = $1 AND b.user_id = $2 AND b.deleted = false
UNION ALL
SELECT sa.permission, false as is_owner
FROM share_access sa
WHERE sa.budget_id = $1 AND sa.shared_with_id = $2
LIMIT 1
`

type CheckBudgetAccessParams struct {
	ID     string      `json:"id"`
	UserID pgtype.UUID `json:"userId"`
}

type CheckBudgetAccessRow struct {
	Permission string `json:"permission"`
	IsOwner    bool   `json:"isOwner"`
}

func (q *Queries) CheckBudgetAccess(ctx context.Context, arg CheckBudgetAccessParams) (CheckBudgetAccessRow, error) {
	row := q.db.QueryRow(ctx, checkBudgetAccess, arg.ID, arg.UserID)
	var i CheckBudgetAccessRow
	err := row.Scan(&i.Permission, &i.IsOwner)
	return i, err
}

const createShareAccess = `-- name: CreateShareAccess :one
INSERT INTO share_access (budget_id, owner_id, shared_with_id, permission)
VALUES ($1, $2, $3, $4)
RETURNING id, budget_id, owner_id, shared_with_id, permission, created_at
`

type CreateShareAccessParams struct {
	BudgetID     pgtype.UUID `json:"budgetId"`
	OwnerID      pgtype.UUID `json:"ownerId"`
	SharedWithID pgtype.UUID `json:"sharedWithId"`
	Permission   string      `json:"permission"`
}

func (q *Queries) CreateShareAccess(ctx context.Context, arg CreateShareAccessParams) (ShareAccess, error) {
	row := q.db.QueryRow(ctx, createShareAccess,
		arg.BudgetID,
		arg.OwnerID,
		arg.SharedWithID,
		arg.Permission,
	)
	var i ShareAccess
	err := row.Scan(
		&i.ID,
		&i.BudgetID,
		&i.OwnerID,
		&i.SharedWithID,
		&i.Permission,
		&i.CreatedAt,
	)
	return i, err
}

const createShareInvitation = `-- name: CreateShareInvitation :one
INSERT INTO share_invitations (budget_id, owner_id, recipient_email, permission, expires_at)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, budget_id, owner_id, recipient_email, permission, status, expires_at, created_at, updated_at
`

type CreateShareInvitationParams struct {
	BudgetID       pgtype.UUID        `json:"budgetId"`
	OwnerID        pgtype.UUID        `json:"ownerId"`
	RecipientEmail string             `json:"recipientEmail"`
	Permission     string             `json:"permission"`
	ExpiresAt      pgtype.Timestamptz `json:"expiresAt"`
}

func (q *Queries) CreateShareInvitation(ctx context.Context, arg CreateShareInvitationParams) (ShareInvitation, error) {
	row := q.db.QueryRow(ctx, createShareInvitation,
		arg.BudgetID,
		arg.OwnerID,
		arg.RecipientEmail,
		arg.Permission,
		arg.ExpiresAt,
	)
	var i ShareInvitation
	err := row.Scan(
		&i.ID,
		&i.BudgetID,
		&i.OwnerID,
		&i.RecipientEmail,
		&i.Permission,
		&i.Status,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteInvitation = `-- name: DeleteInvitation :exec
DELETE FROM share_invitations
WHERE id = $1
`

func (q *Queries) DeleteInvitation(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteInvitation, id)
	return err
}

const deleteShareAccess = `-- name: DeleteShareAccess :exec
DELETE FROM share_access
WHERE id = $1
`

func (q *Queries) DeleteShareAccess(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteShareAccess, id)
	return err
}

const getInvitationByID = `-- name: GetInvitationByID :one
SELECT id, budget_id, owner_id, recipient_email, permission, status, expires_at, created_at, updated_at FROM share_invitations
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetInvitationByID(ctx context.Context, id string) (ShareInvitation, error) {
	row := q.db.QueryRow(ctx, getInvitationByID, id)
	var i ShareInvitation
	err := row.Scan(
		&i.ID,
		&i.BudgetID,
		&i.OwnerID,
		&i.RecipientEmail,
		&i.Permission,
		&i.Status,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getInvitationsByOwner = `-- name: GetInvitationsByOwner :many
SELECT si.id, si.budget_id, si.owner_id, si.recipient_email, si.permission, si.status, si.expires_at, si.created_at, si.updated_at, u.name as recipient_name
FROM share_invitations si
LEFT JOIN users u ON si.recipient_email = u.email
WHERE si.owner_id = $1
ORDER BY si.created_at DESC
`

type GetInvitationsByOwnerRow struct {
	ID             string             `json:"id"`
	BudgetID       pgtype.UUID        `json:"budgetId"`
	OwnerID        pgtype.UUID        `json:"ownerId"`
	RecipientEmail string             `json:"recipientEmail"`
	Permission     string             `json:"permission"`
	Status         pgtype.Text        `json:"status"`
	ExpiresAt      pgtype.Timestamptz `json:"expiresAt"`
	CreatedAt      pgtype.Timestamptz `json:"createdAt"`
	UpdatedAt      pgtype.Timestamptz `json:"updatedAt"`
	RecipientName  pgtype.Text        `json:"recipientName"`
}

func (q *Queries) GetInvitationsByOwner(ctx context.Context, ownerID pgtype.UUID) ([]GetInvitationsByOwnerRow, error) {
	rows, err := q.db.Query(ctx, getInvitationsByOwner, ownerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetInvitationsByOwnerRow{}
	for rows.Next() {
		var i GetInvitationsByOwnerRow
		if err := rows.Scan(
			&i.ID,
			&i.BudgetID,
			&i.OwnerID,
			&i.RecipientEmail,
			&i.Permission,
			&i.Status,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RecipientName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingInvitationsByRecipient = `-- name: GetPendingInvitationsByRecipient :many
SELECT si.id, si.budget_id, si.owner_id, si.recipient_email, si.permission, si.status, si.expires_at, si.created_at, si.updated_at, u.name as owner_name, u.email as owner_email, b.name as budget_name, b.month as budget_month
FROM share_invitations si
JOIN users u ON si.owner_id = u.id
JOIN budgets b ON si.budget_id = b.id
WHERE si.recipient_email = $1 AND si.status = 'pending' AND si.expires_at > NOW()
ORDER BY si.created_at DESC
`

type GetPendingInvitationsByRecipientRow struct {
	ID             string             `json:"id"`
	BudgetID       pgtype.UUID        `json:"budgetId"`
	OwnerID        pgtype.UUID        `json:"ownerId"`
	RecipientEmail string             `json:"recipientEmail"`
	Permission     string             `json:"permission"`
	Status         pgtype.Text        `json:"status"`
	ExpiresAt      pgtype.Timestamptz `json:"expiresAt"`
	CreatedAt      pgtype.Timestamptz `json:"createdAt"`
	UpdatedAt      pgtype.Timestamptz `json:"updatedAt"`
	OwnerName      pgtype.Text        `json:"ownerName"`
	OwnerEmail     string             `json:"ownerEmail"`
	BudgetName     pgtype.Text        `json:"budgetName"`
	BudgetMonth    pgtype.Date        `json:"budgetMonth"`
}

func (q *Queries) GetPendingInvitationsByRecipient(ctx context.Context, recipientEmail string) ([]GetPendingInvitationsByRecipientRow, error) {
	rows, err := q.db.Query(ctx, getPendingInvitationsByRecipient, recipientEmail)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPendingInvitationsByRecipientRow{}
	for rows.Next() {
		var i GetPendingInvitationsByRecipientRow
		if err := rows.Scan(
			&i.ID,
			&i.BudgetID,
			&i.OwnerID,
			&i.RecipientEmail,
			&i.Permission,
			&i.Status,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.OwnerName,
			&i.OwnerEmail,
			&i.BudgetName,
			&i.BudgetMonth,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getShareAccessByBudget = `-- name: GetShareAccessByBudget :many
SELECT sa.id, sa.budget_id, sa.owner_id, sa.shared_with_id, sa.permission, sa.created_at, u.name as shared_with_name, u.email as shared_with_email
FROM share_access sa
JOIN users u ON sa.shared_with_id = u.id
WHERE sa.budget_id = $1
`

type GetShareAccessByBudgetRow struct {
	ID              string             `json:"id"`
	BudgetID        pgtype.UUID        `json:"budgetId"`
	OwnerID         pgtype.UUID        `json:"ownerId"`
	SharedWithID    pgtype.UUID        `json:"sharedWithId"`
	Permission      string             `json:"permission"`
	CreatedAt       pgtype.Timestamptz `json:"createdAt"`
	SharedWithName  pgtype.Text        `json:"sharedWithName"`
	SharedWithEmail string             `json:"sharedWithEmail"`
}

func (q *Queries) GetShareAccessByBudget(ctx context.Context, budgetID pgtype.UUID) ([]GetShareAccessByBudgetRow, error) {
	rows, err := q.db.Query(ctx, getShareAccessByBudget, budgetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetShareAccessByBudgetRow{}
	for rows.Next() {
		var i GetShareAccessByBudgetRow
		if err := rows.Scan(
			&i.ID,
			&i.BudgetID,
			&i.OwnerID,
			&i.SharedWithID,
			&i.Permission,
			&i.CreatedAt,
			&i.SharedWithName,
			&i.SharedWithEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getShareAccessByID = `-- name: GetShareAccessByID :one
SELECT id, budget_id, owner_id, shared_with_id, permission, created_at FROM share_access
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetShareAccessByID(ctx context.Context, id string) (ShareAccess, error) {
	row := q.db.QueryRow(ctx, getShareAccessByID, id)
	var i ShareAccess
	err := row.Scan(
		&i.ID,
		&i.BudgetID,
		&i.OwnerID,
		&i.SharedWithID,
		&i.Permission,
		&i.CreatedAt,
	)
	return i, err
}

const getShareAccessForBudgetAndUser = `-- name: GetShareAccessForBudgetAndUser :one
SELECT sa.id, sa.budget_id, sa.owner_id, sa.shared_with_id, sa.permission, sa.created_at
FROM share_access sa
WHERE sa.budget_id = $1 AND sa.shared_with_id = $2
LIMIT 1
`

type GetShareAccessForBudgetAndUserParams struct {
	BudgetID     pgtype.UUID `json:"budgetId"`
	SharedWithID pgtype.UUID `json:"sharedWithId"`
}

func (q *Queries) GetShareAccessForBudgetAndUser(ctx context.Context, arg GetShareAccessForBudgetAndUserParams) (ShareAccess, error) {
	row := q.db.QueryRow(ctx, getShareAccessForBudgetAndUser, arg.BudgetID, arg.SharedWithID)
	var i ShareAccess
	err := row.Scan(
		&i.ID,
		&i.BudgetID,
		&i.OwnerID,
		&i.SharedWithID,
		&i.Permission,
		&i.CreatedAt,
	)
	return i, err
}

const getShareAccessForUser = `-- name: GetShareAccessForUser :many
SELECT sa.id, sa.budget_id, sa.owner_id, sa.shared_with_id, sa.permission, sa.created_at, o.name as owner_name, o.email as owner_email, b.name as budget_name, b.month as budget_month
FROM share_access sa
JOIN users o ON sa.owner_id = o.id
JOIN budgets b ON sa.budget_id = b.id
WHERE sa.shared_with_id = $1
ORDER BY b.month DESC
`

type GetShareAccessForUserRow struct {
	ID           string             `json:"id"`
	BudgetID     pgtype.UUID        `json:"budgetId"`
	OwnerID      pgtype.UUID        `json:"ownerId"`
	SharedWithID pgtype.UUID        `json:"sharedWithId"`
	Permission   string             `json:"permission"`
	CreatedAt    pgtype.Timestamptz `json:"createdAt"`
	OwnerName    pgtype.Text        `json:"ownerName"`
	OwnerEmail   string             `json:"ownerEmail"`
	BudgetName   pgtype.Text        `json:"budgetName"`
	BudgetMonth  pgtype.Date        `json:"budgetMonth"`
}

func (q *Queries) GetShareAccessForUser(ctx context.Context, sharedWithID pgtype.UUID) ([]GetShareAccessForUserRow, error) {
	rows, err := q.db.Query(ctx, getShareAccessForUser, sharedWithID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetShareAccessForUserRow{}
	for rows.Next() {
		var i GetShareAccessForUserRow
		if err := rows.Scan(
			&i.ID,
			&i.BudgetID,
			&i.OwnerID,
			&i.SharedWithID,
			&i.Permission,
			&i.CreatedAt,
			&i.OwnerName,
			&i.OwnerEmail,
			&i.BudgetName,
			&i.BudgetMonth,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateInvitationStatus = `-- name: UpdateInvitationStatus :one
UPDATE share_invitations
SET status = $1, updated_at = NOW()
WHERE id = $2
RETURNING id, budget_id, owner_id, recipient_email, permission, status, expires_at, created_at, updated_at
`

type UpdateInvitationStatusParams struct {
	Status pgtype.Text `json:"status"`
	ID     string      `json:"id"`
}

func (q *Queries) UpdateInvitationStatus(ctx context.Context, arg UpdateInvitationStatusParams) (ShareInvitation, error) {
	row := q.db.QueryRow(ctx, updateInvitationStatus, arg.Status, arg.ID)
	var i ShareInvitation
	err := row.Scan(
		&i.ID,
		&i.BudgetID,
		&i.OwnerID,
		&i.RecipientEmail,
		&i.Permission,
		&i.Status,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateShareAccess = `-- name: UpdateShareAccess :one
UPDATE share_access
SET permission = $1, updated_at = NOW()
WHERE id = $2
RETURNING id, budget_id, owner_id, shared_with_id, permission, created_at
`

type UpdateShareAccessParams struct {
	Permission string `json:"permission"`
	ID         string `json:"id"`
}

func (q *Queries) UpdateShareAccess(ctx context.Context, arg UpdateShareAccessParams) (ShareAccess, error) {
	row := q.db.QueryRow(ctx, updateShareAccess, arg.Permission, arg.ID)
	var i ShareAccess
	err := row.Scan(
		&i.ID,
		&i.BudgetID,
		&i.OwnerID,
		&i.SharedWithID,
		&i.Permission,
		&i.CreatedAt,
	)
	return i, err
}
