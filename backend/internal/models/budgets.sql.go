// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: budgets.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addBudgetCategory = `-- name: AddBudgetCategory :one
INSERT INTO budget_categories (budget_id, category_id, limit_amount)
VALUES ($1, $2, $3)
RETURNING id, budget_id, category_id, limit_amount, created_at, updated_at
`

type AddBudgetCategoryParams struct {
	BudgetID    pgtype.UUID    `json:"budgetId"`
	CategoryID  pgtype.UUID    `json:"categoryId"`
	LimitAmount pgtype.Numeric `json:"limitAmount"`
}

func (q *Queries) AddBudgetCategory(ctx context.Context, arg AddBudgetCategoryParams) (BudgetCategory, error) {
	row := q.db.QueryRow(ctx, addBudgetCategory, arg.BudgetID, arg.CategoryID, arg.LimitAmount)
	var i BudgetCategory
	err := row.Scan(
		&i.ID,
		&i.BudgetID,
		&i.CategoryID,
		&i.LimitAmount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createBudget = `-- name: CreateBudget :one
INSERT INTO budgets (user_id, name, month, total_limit, total_income)
VALUES ($1, $2, $3, $4, sqlc.narg('total_income'))
RETURNING id, user_id, name, month, total_limit, total_income, created_at, updated_at, deleted
`

type CreateBudgetParams struct {
	UserID     pgtype.UUID    `json:"userId"`
	Name       pgtype.Text    `json:"name"`
	Month      pgtype.Date    `json:"month"`
	TotalLimit pgtype.Numeric `json:"totalLimit"`
	TotalIncome pgtype.Numeric `json:"totalIncome"`
}

func (q *Queries) CreateBudget(ctx context.Context, arg CreateBudgetParams) (Budget, error) {
	row := q.db.QueryRow(ctx, createBudget,
		arg.UserID,
		arg.Name,
		arg.Month,
		arg.TotalLimit,
		arg.TotalIncome,
	)
	var i Budget
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Month,
		&i.TotalLimit,
		&i.TotalIncome,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Deleted,
	)
	return i, err
}

const deleteBudget = `-- name: DeleteBudget :exec
UPDATE budgets
SET deleted = true, updated_at = NOW()
WHERE id = $1
`

func (q *Queries) DeleteBudget(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteBudget, id)
	return err
}

const getBudgetByID = `-- name: GetBudgetByID :one
SELECT id, user_id, name, month, total_limit, total_income, created_at, updated_at, deleted FROM budgets
WHERE id = $1 AND deleted = false
LIMIT 1
`

func (q *Queries) GetBudgetByID(ctx context.Context, id string) (Budget, error) {
	row := q.db.QueryRow(ctx, getBudgetByID, id)
	var i Budget
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Month,
		&i.TotalLimit,
		&i.TotalIncome,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Deleted,
	)
	return i, err
}

const getBudgetByMonth = `-- name: GetBudgetByMonth :one
SELECT id, user_id, name, month, total_limit, total_income, created_at, updated_at, deleted FROM budgets
WHERE user_id = $1 AND month = $2 AND deleted = false
LIMIT 1
`

type GetBudgetByMonthParams struct {
	UserID pgtype.UUID `json:"userId"`
	Month  pgtype.Date `json:"month"`
}

func (q *Queries) GetBudgetByMonth(ctx context.Context, arg GetBudgetByMonthParams) (Budget, error) {
	row := q.db.QueryRow(ctx, getBudgetByMonth, arg.UserID, arg.Month)
	var i Budget
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Month,
		&i.TotalLimit,
		&i.TotalIncome,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Deleted,
	)
	return i, err
}

const getBudgetCategories = `-- name: GetBudgetCategories :many
SELECT bc.id, bc.budget_id, bc.category_id, bc.limit_amount, bc.created_at, bc.updated_at, c.name, c.icon, c.color
FROM budget_categories bc
JOIN categories c ON bc.category_id = c.id
WHERE bc.budget_id = $1
`

type GetBudgetCategoriesRow struct {
	ID          string             `json:"id"`
	BudgetID    pgtype.UUID        `json:"budgetId"`
	CategoryID  pgtype.UUID        `json:"categoryId"`
	LimitAmount pgtype.Numeric     `json:"limitAmount"`
	CreatedAt   pgtype.Timestamptz `json:"createdAt"`
	UpdatedAt   pgtype.Timestamptz `json:"updatedAt"`
	Name        string             `json:"name"`
	Icon        pgtype.Text        `json:"icon"`
	Color       pgtype.Text        `json:"color"`
}

func (q *Queries) GetBudgetCategories(ctx context.Context, budgetID pgtype.UUID) ([]GetBudgetCategoriesRow, error) {
	rows, err := q.db.Query(ctx, getBudgetCategories, budgetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetBudgetCategoriesRow{}
	for rows.Next() {
		var i GetBudgetCategoriesRow
		if err := rows.Scan(
			&i.ID,
			&i.BudgetID,
			&i.CategoryID,
			&i.LimitAmount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Name,
			&i.Icon,
			&i.Color,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBudgetSpent = `-- name: GetBudgetSpent :one
SELECT COALESCE(SUM(t.amount), 0) as total_spent
FROM transactions t
WHERE t.budget_id = $1 
  AND t.type = 'expense' 
  AND t.deleted = false
  AND t.transaction_date >= (SELECT month FROM budgets WHERE id = $1)
  AND t.transaction_date < ((SELECT month FROM budgets WHERE id = $1) + INTERVAL '1 month')
`

func (q *Queries) GetBudgetSpent(ctx context.Context, budgetID pgtype.UUID) (interface{}, error) {
	row := q.db.QueryRow(ctx, getBudgetSpent, budgetID)
	var total_spent interface{}
	err := row.Scan(&total_spent)
	return total_spent, err
}

const listUserBudgets = `-- name: ListUserBudgets :many
SELECT id, user_id, name, month, total_limit, total_income, created_at, updated_at, deleted FROM budgets
WHERE user_id = $1 AND deleted = false
ORDER BY month DESC
`

func (q *Queries) ListUserBudgets(ctx context.Context, userID pgtype.UUID) ([]Budget, error) {
	rows, err := q.db.Query(ctx, listUserBudgets, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Budget{}
	for rows.Next() {
		var i Budget
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Month,
			&i.TotalLimit,
			&i.TotalIncome,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Deleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeBudgetCategory = `-- name: RemoveBudgetCategory :exec
DELETE FROM budget_categories
WHERE id = $1
`

func (q *Queries) RemoveBudgetCategory(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, removeBudgetCategory, id)
	return err
}

const updateBudget = `-- name: UpdateBudget :one
UPDATE budgets
SET
    name = COALESCE($2, name),
    total_limit = COALESCE($3, total_limit),
    total_income = COALESCE(sqlc.narg('total_income'), total_income),
    updated_at = NOW()
WHERE id = $1 AND deleted = false
RETURNING id, user_id, name, month, total_limit, total_income, created_at, updated_at, deleted
`

type UpdateBudgetParams struct {
	ID         string         `json:"id"`
	Name       pgtype.Text    `json:"name"`
	TotalLimit pgtype.Numeric `json:"totalLimit"`
	TotalIncome pgtype.Numeric `json:"totalIncome"`
}

func (q *Queries) UpdateBudget(ctx context.Context, arg UpdateBudgetParams) (Budget, error) {
	row := q.db.QueryRow(ctx, updateBudget, arg.ID, arg.Name, arg.TotalLimit, arg.TotalIncome)
	var i Budget
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Month,
		&i.TotalLimit,
		&i.TotalIncome,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Deleted,
	)
	return i, err
}

const updateBudgetCategory = `-- name: UpdateBudgetCategory :one
UPDATE budget_categories
SET limit_amount = COALESCE($2, limit_amount), updated_at = NOW()
WHERE id = $1
RETURNING id, budget_id, category_id, limit_amount, created_at, updated_at
`

type UpdateBudgetCategoryParams struct {
	ID          string         `json:"id"`
	LimitAmount pgtype.Numeric `json:"limitAmount"`
}

func (q *Queries) UpdateBudgetCategory(ctx context.Context, arg UpdateBudgetCategoryParams) (BudgetCategory, error) {
	row := q.db.QueryRow(ctx, updateBudgetCategory, arg.ID, arg.LimitAmount)
	var i BudgetCategory
	err := row.Scan(
		&i.ID,
		&i.BudgetID,
		&i.CategoryID,
		&i.LimitAmount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
