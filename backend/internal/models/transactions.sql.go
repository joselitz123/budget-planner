// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: transactions.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createTransaction = `-- name: CreateTransaction :one
INSERT INTO transactions (
    user_id, budget_id, category_id, payment_method_id, 
    amount, type, is_transfer, transfer_to_account_id,
    description, transaction_date, is_recurring, recurrence_pattern
)
VALUES (
    $1, $2, $3, $4, 
    $5, $6, $7, $8, 
    $9, $10, $11, $12
)
RETURNING id, user_id, budget_id, category_id, payment_method_id, amount, type, is_transfer, transfer_to_account_id, description, transaction_date, is_recurring, recurrence_pattern, created_at, updated_at, deleted
`

type CreateTransactionParams struct {
	UserID              pgtype.UUID    `json:"userId"`
	BudgetID            pgtype.UUID    `json:"budgetId"`
	CategoryID          pgtype.UUID    `json:"categoryId"`
	PaymentMethodID     pgtype.UUID    `json:"paymentMethodId"`
	Amount              pgtype.Numeric `json:"amount"`
	Type                pgtype.Text    `json:"type"`
	IsTransfer          pgtype.Bool    `json:"isTransfer"`
	TransferToAccountID pgtype.UUID    `json:"transferToAccountId"`
	Description         pgtype.Text    `json:"description"`
	TransactionDate     pgtype.Date    `json:"transactionDate"`
	IsRecurring         pgtype.Bool    `json:"isRecurring"`
	RecurrencePattern   []byte         `json:"recurrencePattern"`
}

func (q *Queries) CreateTransaction(ctx context.Context, arg CreateTransactionParams) (Transaction, error) {
	row := q.db.QueryRow(ctx, createTransaction,
		arg.UserID,
		arg.BudgetID,
		arg.CategoryID,
		arg.PaymentMethodID,
		arg.Amount,
		arg.Type,
		arg.IsTransfer,
		arg.TransferToAccountID,
		arg.Description,
		arg.TransactionDate,
		arg.IsRecurring,
		arg.RecurrencePattern,
	)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.BudgetID,
		&i.CategoryID,
		&i.PaymentMethodID,
		&i.Amount,
		&i.Type,
		&i.IsTransfer,
		&i.TransferToAccountID,
		&i.Description,
		&i.TransactionDate,
		&i.IsRecurring,
		&i.RecurrencePattern,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Deleted,
	)
	return i, err
}

const deleteTransaction = `-- name: DeleteTransaction :exec
UPDATE transactions
SET deleted = true, updated_at = NOW()
WHERE id = $1
`

func (q *Queries) DeleteTransaction(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteTransaction, id)
	return err
}

const getCategorySpent = `-- name: GetCategorySpent :one
SELECT COALESCE(SUM(t.amount), 0) as total_spent
FROM transactions t
WHERE t.budget_id = $1
  AND t.category_id = $2
  AND t.type = 'expense'
  AND t.deleted = false
  AND t.transaction_date >= (SELECT month FROM budgets WHERE id = $1)
  AND t.transaction_date < ((SELECT month FROM budgets WHERE id = $1) + INTERVAL '1 month')
`

type GetCategorySpentParams struct {
	BudgetID   pgtype.UUID `json:"budgetId"`
	CategoryID pgtype.UUID `json:"categoryId"`
}

func (q *Queries) GetCategorySpent(ctx context.Context, arg GetCategorySpentParams) (interface{}, error) {
	row := q.db.QueryRow(ctx, getCategorySpent, arg.BudgetID, arg.CategoryID)
	var total_spent interface{}
	err := row.Scan(&total_spent)
	return total_spent, err
}

const getTransactionByID = `-- name: GetTransactionByID :one
SELECT id, user_id, budget_id, category_id, payment_method_id, amount, type, is_transfer, transfer_to_account_id, description, transaction_date, is_recurring, recurrence_pattern, created_at, updated_at, deleted FROM transactions
WHERE id = $1 AND deleted = false
LIMIT 1
`

func (q *Queries) GetTransactionByID(ctx context.Context, id string) (Transaction, error) {
	row := q.db.QueryRow(ctx, getTransactionByID, id)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.BudgetID,
		&i.CategoryID,
		&i.PaymentMethodID,
		&i.Amount,
		&i.Type,
		&i.IsTransfer,
		&i.TransferToAccountID,
		&i.Description,
		&i.TransactionDate,
		&i.IsRecurring,
		&i.RecurrencePattern,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Deleted,
	)
	return i, err
}

const getTransactionsByBudget = `-- name: GetTransactionsByBudget :many
SELECT id, user_id, budget_id, category_id, payment_method_id, amount, type, is_transfer, transfer_to_account_id, description, transaction_date, is_recurring, recurrence_pattern, created_at, updated_at, deleted FROM transactions
WHERE budget_id = $1 AND deleted = false
ORDER BY transaction_date DESC
`

func (q *Queries) GetTransactionsByBudget(ctx context.Context, budgetID pgtype.UUID) ([]Transaction, error) {
	rows, err := q.db.Query(ctx, getTransactionsByBudget, budgetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Transaction{}
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.BudgetID,
			&i.CategoryID,
			&i.PaymentMethodID,
			&i.Amount,
			&i.Type,
			&i.IsTransfer,
			&i.TransferToAccountID,
			&i.Description,
			&i.TransactionDate,
			&i.IsRecurring,
			&i.RecurrencePattern,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Deleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTransactions = `-- name: ListTransactions :many
SELECT id, user_id, budget_id, category_id, payment_method_id, amount, type, is_transfer, transfer_to_account_id, description, transaction_date, is_recurring, recurrence_pattern, created_at, updated_at, deleted FROM transactions
WHERE user_id = $1
  AND deleted = false
  AND ($2::date IS NULL OR transaction_date >= $2)
  AND ($3::date IS NULL OR transaction_date <= $3)
  AND ($4 = '' OR category_id = $4::uuid)
  AND ($5 = '' OR budget_id = $5::uuid)
ORDER BY transaction_date DESC
LIMIT $6 OFFSET $7
`

type ListTransactionsParams struct {
	UserID  pgtype.UUID `json:"userId"`
	Column2 pgtype.Date `json:"column2"`
	Column3 pgtype.Date `json:"column3"`
	Column4 string      `json:"column4"`
	Column5 string      `json:"column5"`
	Limit   int32       `json:"limit"`
	Offset  int32       `json:"offset"`
}

func (q *Queries) ListTransactions(ctx context.Context, arg ListTransactionsParams) ([]Transaction, error) {
	rows, err := q.db.Query(ctx, listTransactions,
		arg.UserID,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Transaction{}
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.BudgetID,
			&i.CategoryID,
			&i.PaymentMethodID,
			&i.Amount,
			&i.Type,
			&i.IsTransfer,
			&i.TransferToAccountID,
			&i.Description,
			&i.TransactionDate,
			&i.IsRecurring,
			&i.RecurrencePattern,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Deleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTransaction = `-- name: UpdateTransaction :one
UPDATE transactions
SET
    budget_id = COALESCE($2, budget_id),
    category_id = COALESCE($3, category_id),
    payment_method_id = COALESCE($4, payment_method_id),
    amount = COALESCE($5, amount),
    type = COALESCE($6, type),
    is_transfer = COALESCE($7, is_transfer),
    transfer_to_account_id = COALESCE($8, transfer_to_account_id),
    description = COALESCE($9, description),
    transaction_date = COALESCE($10, transaction_date),
    is_recurring = COALESCE($11, is_recurring),
    recurrence_pattern = COALESCE($12, recurrence_pattern),
    updated_at = NOW()
WHERE id = $1 AND deleted = false
RETURNING id, user_id, budget_id, category_id, payment_method_id, amount, type, is_transfer, transfer_to_account_id, description, transaction_date, is_recurring, recurrence_pattern, created_at, updated_at, deleted
`

type UpdateTransactionParams struct {
	ID                  string         `json:"id"`
	BudgetID            pgtype.UUID    `json:"budgetId"`
	CategoryID          pgtype.UUID    `json:"categoryId"`
	PaymentMethodID     pgtype.UUID    `json:"paymentMethodId"`
	Amount              pgtype.Numeric `json:"amount"`
	Type                pgtype.Text    `json:"type"`
	IsTransfer          pgtype.Bool    `json:"isTransfer"`
	TransferToAccountID pgtype.UUID    `json:"transferToAccountId"`
	Description         pgtype.Text    `json:"description"`
	TransactionDate     pgtype.Date    `json:"transactionDate"`
	IsRecurring         pgtype.Bool    `json:"isRecurring"`
	RecurrencePattern   []byte         `json:"recurrencePattern"`
}

func (q *Queries) UpdateTransaction(ctx context.Context, arg UpdateTransactionParams) (Transaction, error) {
	row := q.db.QueryRow(ctx, updateTransaction,
		arg.ID,
		arg.BudgetID,
		arg.CategoryID,
		arg.PaymentMethodID,
		arg.Amount,
		arg.Type,
		arg.IsTransfer,
		arg.TransferToAccountID,
		arg.Description,
		arg.TransactionDate,
		arg.IsRecurring,
		arg.RecurrencePattern,
	)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.BudgetID,
		&i.CategoryID,
		&i.PaymentMethodID,
		&i.Amount,
		&i.Type,
		&i.IsTransfer,
		&i.TransferToAccountID,
		&i.Description,
		&i.TransactionDate,
		&i.IsRecurring,
		&i.RecurrencePattern,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Deleted,
	)
	return i, err
}
