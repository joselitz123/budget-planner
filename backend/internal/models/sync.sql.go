// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: sync.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countPendingSyncOperations = `-- name: CountPendingSyncOperations :one
SELECT COUNT(*) as count
FROM sync_operations
WHERE user_id = $1 AND status = 'pending'
`

func (q *Queries) CountPendingSyncOperations(ctx context.Context, userID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countPendingSyncOperations, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createSyncOperation = `-- name: CreateSyncOperation :one
INSERT INTO sync_operations (user_id, table_name, record_id, operation, local_data, server_data, status)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, user_id, table_name, record_id, operation, local_data, server_data, status, error_message, attempt_count, last_attempt_at, created_at, updated_at
`

type CreateSyncOperationParams struct {
	UserID     pgtype.UUID `json:"userId"`
	TableName  string      `json:"tableName"`
	RecordID   string      `json:"recordId"`
	Operation  string      `json:"operation"`
	LocalData  []byte      `json:"localData"`
	ServerData []byte      `json:"serverData"`
	Status     pgtype.Text `json:"status"`
}

func (q *Queries) CreateSyncOperation(ctx context.Context, arg CreateSyncOperationParams) (SyncOperation, error) {
	row := q.db.QueryRow(ctx, createSyncOperation,
		arg.UserID,
		arg.TableName,
		arg.RecordID,
		arg.Operation,
		arg.LocalData,
		arg.ServerData,
		arg.Status,
	)
	var i SyncOperation
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TableName,
		&i.RecordID,
		&i.Operation,
		&i.LocalData,
		&i.ServerData,
		&i.Status,
		&i.ErrorMessage,
		&i.AttemptCount,
		&i.LastAttemptAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteSyncOperation = `-- name: DeleteSyncOperation :exec
DELETE FROM sync_operations
WHERE id = $1
`

func (q *Queries) DeleteSyncOperation(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteSyncOperation, id)
	return err
}

const deleteSyncedOperations = `-- name: DeleteSyncedOperations :exec
DELETE FROM sync_operations
WHERE user_id = $1 AND status = 'synced' AND created_at < NOW() - INTERVAL '30 days'
`

func (q *Queries) DeleteSyncedOperations(ctx context.Context, userID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteSyncedOperations, userID)
	return err
}

const getBudgetsSince = `-- name: GetBudgetsSince :many

SELECT id, user_id, name, month, total_limit, created_at, updated_at, deleted FROM budgets
WHERE user_id = $1
  AND deleted = false
  AND ($2 IS NULL OR updated_at > $2)
ORDER BY updated_at ASC
`

type GetBudgetsSinceParams struct {
	UserID  pgtype.UUID `json:"userId"`
	Column2 interface{} `json:"column2"`
}

// Sync pull queries - fetch records updated since last sync
func (q *Queries) GetBudgetsSince(ctx context.Context, arg GetBudgetsSinceParams) ([]Budget, error) {
	rows, err := q.db.Query(ctx, getBudgetsSince, arg.UserID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Budget{}
	for rows.Next() {
		var i Budget
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Month,
			&i.TotalLimit,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Deleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCategoriesSince = `-- name: GetCategoriesSince :many
SELECT id, user_id, name, icon, color, is_system, default_limit, created_at, updated_at, deleted FROM categories
WHERE user_id = $1
  AND deleted = false
  AND ($2 IS NULL OR updated_at > $2)
ORDER BY updated_at ASC
`

type GetCategoriesSinceParams struct {
	UserID  pgtype.UUID `json:"userId"`
	Column2 interface{} `json:"column2"`
}

func (q *Queries) GetCategoriesSince(ctx context.Context, arg GetCategoriesSinceParams) ([]Category, error) {
	rows, err := q.db.Query(ctx, getCategoriesSince, arg.UserID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Category{}
	for rows.Next() {
		var i Category
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Icon,
			&i.Color,
			&i.IsSystem,
			&i.DefaultLimit,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Deleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFailedSyncOperations = `-- name: GetFailedSyncOperations :many
SELECT id, user_id, table_name, record_id, operation, local_data, server_data, status, error_message, attempt_count, last_attempt_at, created_at, updated_at FROM sync_operations
WHERE user_id = $1 AND status = 'failed'
ORDER BY created_at ASC
`

func (q *Queries) GetFailedSyncOperations(ctx context.Context, userID pgtype.UUID) ([]SyncOperation, error) {
	rows, err := q.db.Query(ctx, getFailedSyncOperations, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SyncOperation{}
	for rows.Next() {
		var i SyncOperation
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TableName,
			&i.RecordID,
			&i.Operation,
			&i.LocalData,
			&i.ServerData,
			&i.Status,
			&i.ErrorMessage,
			&i.AttemptCount,
			&i.LastAttemptAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingSyncOperations = `-- name: GetPendingSyncOperations :many
SELECT id, user_id, table_name, record_id, operation, local_data, server_data, status, error_message, attempt_count, last_attempt_at, created_at, updated_at FROM sync_operations
WHERE user_id = $1 AND status = 'pending'
ORDER BY created_at ASC
`

func (q *Queries) GetPendingSyncOperations(ctx context.Context, userID pgtype.UUID) ([]SyncOperation, error) {
	rows, err := q.db.Query(ctx, getPendingSyncOperations, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SyncOperation{}
	for rows.Next() {
		var i SyncOperation
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TableName,
			&i.RecordID,
			&i.Operation,
			&i.LocalData,
			&i.ServerData,
			&i.Status,
			&i.ErrorMessage,
			&i.AttemptCount,
			&i.LastAttemptAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSyncOperationByID = `-- name: GetSyncOperationByID :one
SELECT id, user_id, table_name, record_id, operation, local_data, server_data, status, error_message, attempt_count, last_attempt_at, created_at, updated_at FROM sync_operations
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetSyncOperationByID(ctx context.Context, id string) (SyncOperation, error) {
	row := q.db.QueryRow(ctx, getSyncOperationByID, id)
	var i SyncOperation
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TableName,
		&i.RecordID,
		&i.Operation,
		&i.LocalData,
		&i.ServerData,
		&i.Status,
		&i.ErrorMessage,
		&i.AttemptCount,
		&i.LastAttemptAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSyncOperationsByUser = `-- name: GetSyncOperationsByUser :many
SELECT id, user_id, table_name, record_id, operation, local_data, server_data, status, error_message, attempt_count, last_attempt_at, created_at, updated_at FROM sync_operations
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetSyncOperationsByUserParams struct {
	UserID pgtype.UUID `json:"userId"`
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
}

func (q *Queries) GetSyncOperationsByUser(ctx context.Context, arg GetSyncOperationsByUserParams) ([]SyncOperation, error) {
	rows, err := q.db.Query(ctx, getSyncOperationsByUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SyncOperation{}
	for rows.Next() {
		var i SyncOperation
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TableName,
			&i.RecordID,
			&i.Operation,
			&i.LocalData,
			&i.ServerData,
			&i.Status,
			&i.ErrorMessage,
			&i.AttemptCount,
			&i.LastAttemptAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransactionsSince = `-- name: GetTransactionsSince :many
SELECT id, user_id, budget_id, category_id, payment_method_id, amount, type, is_transfer, transfer_to_account_id, description, transaction_date, is_recurring, recurrence_pattern, created_at, updated_at, deleted FROM transactions
WHERE user_id = $1
  AND deleted = false
  AND ($2 IS NULL OR updated_at > $2)
ORDER BY updated_at ASC
`

type GetTransactionsSinceParams struct {
	UserID  pgtype.UUID `json:"userId"`
	Column2 interface{} `json:"column2"`
}

func (q *Queries) GetTransactionsSince(ctx context.Context, arg GetTransactionsSinceParams) ([]Transaction, error) {
	rows, err := q.db.Query(ctx, getTransactionsSince, arg.UserID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Transaction{}
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.BudgetID,
			&i.CategoryID,
			&i.PaymentMethodID,
			&i.Amount,
			&i.Type,
			&i.IsTransfer,
			&i.TransferToAccountID,
			&i.Description,
			&i.TransactionDate,
			&i.IsRecurring,
			&i.RecurrencePattern,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Deleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const resolveSyncOperation = `-- name: ResolveSyncOperation :exec
UPDATE sync_operations
SET
    status = $2,
    updated_at = NOW()
WHERE id = $1
`

type ResolveSyncOperationParams struct {
	ID     string      `json:"id"`
	Status pgtype.Text `json:"status"`
}

func (q *Queries) ResolveSyncOperation(ctx context.Context, arg ResolveSyncOperationParams) error {
	_, err := q.db.Exec(ctx, resolveSyncOperation, arg.ID, arg.Status)
	return err
}

const updateSyncOperationStatus = `-- name: UpdateSyncOperationStatus :one
UPDATE sync_operations
SET
    status = $1,
    error_message = COALESCE($3, error_message),
    attempt_count = attempt_count + 1,
    last_attempt_at = NOW(),
    updated_at = NOW()
WHERE id = $2
RETURNING id, user_id, table_name, record_id, operation, local_data, server_data, status, error_message, attempt_count, last_attempt_at, created_at, updated_at
`

type UpdateSyncOperationStatusParams struct {
	Status       pgtype.Text `json:"status"`
	ID           string      `json:"id"`
	ErrorMessage pgtype.Text `json:"errorMessage"`
}

func (q *Queries) UpdateSyncOperationStatus(ctx context.Context, arg UpdateSyncOperationStatusParams) (SyncOperation, error) {
	row := q.db.QueryRow(ctx, updateSyncOperationStatus, arg.Status, arg.ID, arg.ErrorMessage)
	var i SyncOperation
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TableName,
		&i.RecordID,
		&i.Operation,
		&i.LocalData,
		&i.ServerData,
		&i.Status,
		&i.ErrorMessage,
		&i.AttemptCount,
		&i.LastAttemptAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
