// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: payment_methods.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createPaymentMethod = `-- name: CreatePaymentMethod :one
INSERT INTO payment_methods (
    user_id, name, type, last_four, brand,
    is_default, is_active, credit_limit, current_balance
)
VALUES (
    $1, $2, $3, $4, $5,
    $6, $7, $8, $9
)
RETURNING id, user_id, name, type, last_four, brand, is_default, is_active, credit_limit, current_balance, created_at, updated_at, deleted
`

type CreatePaymentMethodParams struct {
	UserID         pgtype.UUID    `json:"userId"`
	Name           string         `json:"name"`
	Type           string         `json:"type"`
	LastFour       pgtype.Text    `json:"lastFour"`
	Brand          pgtype.Text    `json:"brand"`
	IsDefault      pgtype.Bool    `json:"isDefault"`
	IsActive       pgtype.Bool    `json:"isActive"`
	CreditLimit    pgtype.Numeric `json:"creditLimit"`
	CurrentBalance pgtype.Numeric `json:"currentBalance"`
}

func (q *Queries) CreatePaymentMethod(ctx context.Context, arg CreatePaymentMethodParams) (PaymentMethod, error) {
	row := q.db.QueryRow(ctx, createPaymentMethod,
		arg.UserID,
		arg.Name,
		arg.Type,
		arg.LastFour,
		arg.Brand,
		arg.IsDefault,
		arg.IsActive,
		arg.CreditLimit,
		arg.CurrentBalance,
	)
	var i PaymentMethod
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Type,
		&i.LastFour,
		&i.Brand,
		&i.IsDefault,
		&i.IsActive,
		&i.CreditLimit,
		&i.CurrentBalance,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Deleted,
	)
	return i, err
}

const deletePaymentMethod = `-- name: DeletePaymentMethod :exec
UPDATE payment_methods
SET deleted = true, updated_at = NOW()
WHERE id = $1
`

func (q *Queries) DeletePaymentMethod(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deletePaymentMethod, id)
	return err
}

const getPaymentMethodByID = `-- name: GetPaymentMethodByID :one
SELECT id, user_id, name, type, last_four, brand, is_default, is_active, credit_limit, current_balance, created_at, updated_at, deleted FROM payment_methods
WHERE id = $1 AND deleted = false
LIMIT 1
`

func (q *Queries) GetPaymentMethodByID(ctx context.Context, id string) (PaymentMethod, error) {
	row := q.db.QueryRow(ctx, getPaymentMethodByID, id)
	var i PaymentMethod
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Type,
		&i.LastFour,
		&i.Brand,
		&i.IsDefault,
		&i.IsActive,
		&i.CreditLimit,
		&i.CurrentBalance,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Deleted,
	)
	return i, err
}

const listPaymentMethods = `-- name: ListPaymentMethods :many
SELECT id, user_id, name, type, last_four, brand, is_default, is_active, credit_limit, current_balance, created_at, updated_at, deleted FROM payment_methods
WHERE user_id = $1 AND deleted = false
ORDER BY is_default DESC, created_at DESC
`

func (q *Queries) ListPaymentMethods(ctx context.Context, userID pgtype.UUID) ([]PaymentMethod, error) {
	rows, err := q.db.Query(ctx, listPaymentMethods, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PaymentMethod{}
	for rows.Next() {
		var i PaymentMethod
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Type,
			&i.LastFour,
			&i.Brand,
			&i.IsDefault,
			&i.IsActive,
			&i.CreditLimit,
			&i.CurrentBalance,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Deleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setDefaultPaymentMethod = `-- name: SetDefaultPaymentMethod :exec
UPDATE payment_methods
SET is_default = false
WHERE user_id = $1 AND deleted = false
`

func (q *Queries) SetDefaultPaymentMethod(ctx context.Context, userID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, setDefaultPaymentMethod, userID)
	return err
}

const updatePaymentMethod = `-- name: UpdatePaymentMethod :one
UPDATE payment_methods
SET
    name = COALESCE($2, name),
    type = COALESCE($3, type),
    last_four = COALESCE($4, last_four),
    brand = COALESCE($5, brand),
    is_default = COALESCE($6, is_default),
    is_active = COALESCE($7, is_active),
    credit_limit = COALESCE($8, credit_limit),
    current_balance = COALESCE($9, current_balance),
    updated_at = NOW()
WHERE id = $1 AND deleted = false
RETURNING id, user_id, name, type, last_four, brand, is_default, is_active, credit_limit, current_balance, created_at, updated_at, deleted
`

type UpdatePaymentMethodParams struct {
	ID             string         `json:"id"`
	Name           pgtype.Text    `json:"name"`
	Type           pgtype.Text    `json:"type"`
	LastFour       pgtype.Text    `json:"lastFour"`
	Brand          pgtype.Text    `json:"brand"`
	IsDefault      pgtype.Bool    `json:"isDefault"`
	IsActive       pgtype.Bool    `json:"isActive"`
	CreditLimit    pgtype.Numeric `json:"creditLimit"`
	CurrentBalance pgtype.Numeric `json:"currentBalance"`
}

func (q *Queries) UpdatePaymentMethod(ctx context.Context, arg UpdatePaymentMethodParams) (PaymentMethod, error) {
	row := q.db.QueryRow(ctx, updatePaymentMethod,
		arg.ID,
		arg.Name,
		arg.Type,
		arg.LastFour,
		arg.Brand,
		arg.IsDefault,
		arg.IsActive,
		arg.CreditLimit,
		arg.CurrentBalance,
	)
	var i PaymentMethod
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Type,
		&i.LastFour,
		&i.Brand,
		&i.IsDefault,
		&i.IsActive,
		&i.CreditLimit,
		&i.CurrentBalance,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Deleted,
	)
	return i, err
}
