// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: analytics.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getCategoryReport = `-- name: GetCategoryReport :many
SELECT 
    DATE_TRUNC('day', transaction_date) as date,
    COALESCE(SUM(amount), 0) as total,
    COUNT(*) as transaction_count
FROM transactions
WHERE user_id = $1 
  AND category_id = $2
  AND type = 'expense'
  AND deleted = false
  AND transaction_date >= $3
  AND transaction_date <= $4
GROUP BY DATE_TRUNC('day', transaction_date)
ORDER BY date ASC
`

type GetCategoryReportParams struct {
	UserID            pgtype.UUID `json:"userId"`
	CategoryID        pgtype.UUID `json:"categoryId"`
	TransactionDate   pgtype.Date `json:"transactionDate"`
	TransactionDate_2 pgtype.Date `json:"transactionDate2"`
}

type GetCategoryReportRow struct {
	Date             pgtype.Interval `json:"date"`
	Total            interface{}     `json:"total"`
	TransactionCount int64           `json:"transactionCount"`
}

func (q *Queries) GetCategoryReport(ctx context.Context, arg GetCategoryReportParams) ([]GetCategoryReportRow, error) {
	rows, err := q.db.Query(ctx, getCategoryReport,
		arg.UserID,
		arg.CategoryID,
		arg.TransactionDate,
		arg.TransactionDate_2,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCategoryReportRow{}
	for rows.Next() {
		var i GetCategoryReportRow
		if err := rows.Scan(&i.Date, &i.Total, &i.TransactionCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDashboardSummary = `-- name: GetDashboardSummary :one
WITH budget_month AS (
    SELECT month FROM budgets WHERE id = $1
),
spent AS (
    SELECT COALESCE(SUM(amount), 0) as total
    FROM transactions t
    WHERE t.budget_id = $1 
      AND t.type = 'expense' 
      AND t.deleted = false
      AND t.transaction_date >= (SELECT month FROM budget_month)
      AND t.transaction_date < ((SELECT month FROM budget_month) + INTERVAL '1 month')
),
income AS (
    SELECT COALESCE(SUM(amount), 0) as total
    FROM transactions t
    WHERE t.budget_id = $1 
      AND t.type = 'income' 
      AND t.deleted = false
      AND t.transaction_date >= (SELECT month FROM budget_month)
      AND t.transaction_date < ((SELECT month FROM budget_month) + INTERVAL '1 month')
),
transactions_count AS (
    SELECT COUNT(*) as total
    FROM transactions t
    WHERE t.budget_id = $1 AND t.deleted = false
      AND t.transaction_date >= (SELECT month FROM budget_month)
      AND t.transaction_date < ((SELECT month FROM budget_month) + INTERVAL '1 month')
)
SELECT 
    b.id, b.user_id, b.name, b.month, b.total_limit, b.created_at, b.updated_at, b.deleted,
    s.total as total_spent,
    i.total as total_income,
    tc.total as transaction_count
FROM budgets b
CROSS JOIN spent s
CROSS JOIN income i
CROSS JOIN transactions_count tc
WHERE b.id = $1
`

type GetDashboardSummaryRow struct {
	ID               string             `json:"id"`
	UserID           pgtype.UUID        `json:"userId"`
	Name             pgtype.Text        `json:"name"`
	Month            pgtype.Date        `json:"month"`
	TotalLimit       pgtype.Numeric     `json:"totalLimit"`
	CreatedAt        pgtype.Timestamptz `json:"createdAt"`
	UpdatedAt        pgtype.Timestamptz `json:"updatedAt"`
	Deleted          pgtype.Bool        `json:"deleted"`
	TotalSpent       interface{}        `json:"totalSpent"`
	TotalIncome      interface{}        `json:"totalIncome"`
	TransactionCount int64              `json:"transactionCount"`
}

func (q *Queries) GetDashboardSummary(ctx context.Context, id string) (GetDashboardSummaryRow, error) {
	row := q.db.QueryRow(ctx, getDashboardSummary, id)
	var i GetDashboardSummaryRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Month,
		&i.TotalLimit,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Deleted,
		&i.TotalSpent,
		&i.TotalIncome,
		&i.TransactionCount,
	)
	return i, err
}

const getRecentTransactions = `-- name: GetRecentTransactions :many
SELECT t.id, t.user_id, t.budget_id, t.category_id, t.payment_method_id, t.amount, t.type, t.is_transfer, t.transfer_to_account_id, t.description, t.transaction_date, t.is_recurring, t.recurrence_pattern, t.created_at, t.updated_at, t.deleted, c.name as category_name, c.icon as category_icon, c.color as category_color,
       pm.name as payment_method_name, pm.type as payment_method_type
FROM transactions t
LEFT JOIN categories c ON t.category_id = c.id
LEFT JOIN payment_methods pm ON t.payment_method_id = pm.id
WHERE t.user_id = $1 AND t.deleted = false
ORDER BY t.transaction_date DESC, t.created_at DESC
LIMIT $2 OFFSET $3
`

type GetRecentTransactionsParams struct {
	UserID pgtype.UUID `json:"userId"`
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
}

type GetRecentTransactionsRow struct {
	ID                  string             `json:"id"`
	UserID              pgtype.UUID        `json:"userId"`
	BudgetID            pgtype.UUID        `json:"budgetId"`
	CategoryID          pgtype.UUID        `json:"categoryId"`
	PaymentMethodID     pgtype.UUID        `json:"paymentMethodId"`
	Amount              pgtype.Numeric     `json:"amount"`
	Type                pgtype.Text        `json:"type"`
	IsTransfer          pgtype.Bool        `json:"isTransfer"`
	TransferToAccountID pgtype.UUID        `json:"transferToAccountId"`
	Description         pgtype.Text        `json:"description"`
	TransactionDate     pgtype.Date        `json:"transactionDate"`
	IsRecurring         pgtype.Bool        `json:"isRecurring"`
	RecurrencePattern   []byte             `json:"recurrencePattern"`
	CreatedAt           pgtype.Timestamptz `json:"createdAt"`
	UpdatedAt           pgtype.Timestamptz `json:"updatedAt"`
	Deleted             pgtype.Bool        `json:"deleted"`
	CategoryName        pgtype.Text        `json:"categoryName"`
	CategoryIcon        pgtype.Text        `json:"categoryIcon"`
	CategoryColor       pgtype.Text        `json:"categoryColor"`
	PaymentMethodName   pgtype.Text        `json:"paymentMethodName"`
	PaymentMethodType   pgtype.Text        `json:"paymentMethodType"`
}

func (q *Queries) GetRecentTransactions(ctx context.Context, arg GetRecentTransactionsParams) ([]GetRecentTransactionsRow, error) {
	rows, err := q.db.Query(ctx, getRecentTransactions, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRecentTransactionsRow{}
	for rows.Next() {
		var i GetRecentTransactionsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.BudgetID,
			&i.CategoryID,
			&i.PaymentMethodID,
			&i.Amount,
			&i.Type,
			&i.IsTransfer,
			&i.TransferToAccountID,
			&i.Description,
			&i.TransactionDate,
			&i.IsRecurring,
			&i.RecurrencePattern,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Deleted,
			&i.CategoryName,
			&i.CategoryIcon,
			&i.CategoryColor,
			&i.PaymentMethodName,
			&i.PaymentMethodType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSpendingByCategory = `-- name: GetSpendingByCategory :many
SELECT 
    c.id,
    c.name,
    c.icon,
    c.color,
    COALESCE(SUM(t.amount), 0) as total_spent,
    COALESCE(SUM(t.amount), 0) / bc.limit_amount * 100 as percentage
FROM budget_categories bc
JOIN categories c ON bc.category_id = c.id
LEFT JOIN transactions t ON t.category_id = c.id 
    AND t.budget_id = $1 
    AND t.type = 'expense' 
    AND t.deleted = false
    AND t.transaction_date >= (SELECT month FROM budgets WHERE id = $1)
    AND t.transaction_date < ((SELECT month FROM budgets WHERE id = $1) + INTERVAL '1 month')
WHERE bc.budget_id = $1
GROUP BY c.id, c.name, c.icon, c.color, bc.limit_amount
ORDER BY total_spent DESC
`

type GetSpendingByCategoryRow struct {
	ID         string      `json:"id"`
	Name       string      `json:"name"`
	Icon       pgtype.Text `json:"icon"`
	Color      pgtype.Text `json:"color"`
	TotalSpent interface{} `json:"totalSpent"`
	Percentage int32       `json:"percentage"`
}

func (q *Queries) GetSpendingByCategory(ctx context.Context, budgetID pgtype.UUID) ([]GetSpendingByCategoryRow, error) {
	rows, err := q.db.Query(ctx, getSpendingByCategory, budgetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSpendingByCategoryRow{}
	for rows.Next() {
		var i GetSpendingByCategoryRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Icon,
			&i.Color,
			&i.TotalSpent,
			&i.Percentage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSpendingTrends = `-- name: GetSpendingTrends :many
SELECT 
    DATE_TRUNC('month', transaction_date) as month,
    SUM(CASE WHEN type = 'expense' THEN amount ELSE 0 END) as expenses,
    SUM(CASE WHEN type = 'income' THEN amount ELSE 0 END) as income
FROM transactions
WHERE user_id = $1 
  AND deleted = false
  AND transaction_date >= $2
  AND transaction_date <= $3
GROUP BY DATE_TRUNC('month', transaction_date)
ORDER BY month ASC
`

type GetSpendingTrendsParams struct {
	UserID            pgtype.UUID `json:"userId"`
	TransactionDate   pgtype.Date `json:"transactionDate"`
	TransactionDate_2 pgtype.Date `json:"transactionDate2"`
}

type GetSpendingTrendsRow struct {
	Month    pgtype.Interval `json:"month"`
	Expenses int64           `json:"expenses"`
	Income   int64           `json:"income"`
}

func (q *Queries) GetSpendingTrends(ctx context.Context, arg GetSpendingTrendsParams) ([]GetSpendingTrendsRow, error) {
	rows, err := q.db.Query(ctx, getSpendingTrends, arg.UserID, arg.TransactionDate, arg.TransactionDate_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSpendingTrendsRow{}
	for rows.Next() {
		var i GetSpendingTrendsRow
		if err := rows.Scan(&i.Month, &i.Expenses, &i.Income); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
