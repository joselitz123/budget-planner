// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: reflections.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createReflection = `-- name: CreateReflection :one
INSERT INTO reflections (user_id, budget_id, overall_rating, is_private)
VALUES ($1, $2, $3, $4)
RETURNING id, user_id, budget_id, overall_rating, is_private, created_at, updated_at, deleted
`

type CreateReflectionParams struct {
	UserID        pgtype.UUID `json:"userId"`
	BudgetID      pgtype.UUID `json:"budgetId"`
	OverallRating pgtype.Int4 `json:"overallRating"`
	IsPrivate     pgtype.Bool `json:"isPrivate"`
}

func (q *Queries) CreateReflection(ctx context.Context, arg CreateReflectionParams) (Reflection, error) {
	row := q.db.QueryRow(ctx, createReflection,
		arg.UserID,
		arg.BudgetID,
		arg.OverallRating,
		arg.IsPrivate,
	)
	var i Reflection
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.BudgetID,
		&i.OverallRating,
		&i.IsPrivate,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Deleted,
	)
	return i, err
}

const createReflectionQuestion = `-- name: CreateReflectionQuestion :one
INSERT INTO reflection_questions (reflection_id, sequence, question_id, question_text, answer, mood)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, reflection_id, sequence, question_id, question_text, answer, mood, created_at, updated_at
`

type CreateReflectionQuestionParams struct {
	ReflectionID pgtype.UUID `json:"reflectionId"`
	Sequence     pgtype.Int4 `json:"sequence"`
	QuestionID   string      `json:"questionId"`
	QuestionText string      `json:"questionText"`
	Answer       pgtype.Text `json:"answer"`
	Mood         pgtype.Text `json:"mood"`
}

func (q *Queries) CreateReflectionQuestion(ctx context.Context, arg CreateReflectionQuestionParams) (ReflectionQuestion, error) {
	row := q.db.QueryRow(ctx, createReflectionQuestion,
		arg.ReflectionID,
		arg.Sequence,
		arg.QuestionID,
		arg.QuestionText,
		arg.Answer,
		arg.Mood,
	)
	var i ReflectionQuestion
	err := row.Scan(
		&i.ID,
		&i.ReflectionID,
		&i.Sequence,
		&i.QuestionID,
		&i.QuestionText,
		&i.Answer,
		&i.Mood,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createReflectionTemplate = `-- name: CreateReflectionTemplate :one
INSERT INTO reflection_templates (name, is_active, version)
VALUES ($1, $2, $3)
RETURNING id, name, is_active, version, created_at, updated_at
`

type CreateReflectionTemplateParams struct {
	Name     string      `json:"name"`
	IsActive pgtype.Bool `json:"isActive"`
	Version  pgtype.Int4 `json:"version"`
}

func (q *Queries) CreateReflectionTemplate(ctx context.Context, arg CreateReflectionTemplateParams) (ReflectionTemplate, error) {
	row := q.db.QueryRow(ctx, createReflectionTemplate, arg.Name, arg.IsActive, arg.Version)
	var i ReflectionTemplate
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.IsActive,
		&i.Version,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteReflection = `-- name: DeleteReflection :exec
UPDATE reflections
SET deleted = true, updated_at = NOW()
WHERE id = $1
`

func (q *Queries) DeleteReflection(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteReflection, id)
	return err
}

const deleteReflectionTemplate = `-- name: DeleteReflectionTemplate :exec
DELETE FROM reflection_templates
WHERE id = $1
`

func (q *Queries) DeleteReflectionTemplate(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteReflectionTemplate, id)
	return err
}

const getReflectionByBudget = `-- name: GetReflectionByBudget :one
SELECT id, user_id, budget_id, overall_rating, is_private, created_at, updated_at, deleted FROM reflections
WHERE budget_id = $1 AND deleted = false
LIMIT 1
`

func (q *Queries) GetReflectionByBudget(ctx context.Context, budgetID pgtype.UUID) (Reflection, error) {
	row := q.db.QueryRow(ctx, getReflectionByBudget, budgetID)
	var i Reflection
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.BudgetID,
		&i.OverallRating,
		&i.IsPrivate,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Deleted,
	)
	return i, err
}

const getReflectionByID = `-- name: GetReflectionByID :one
SELECT id, user_id, budget_id, overall_rating, is_private, created_at, updated_at, deleted FROM reflections
WHERE id = $1 AND deleted = false
LIMIT 1
`

func (q *Queries) GetReflectionByID(ctx context.Context, id string) (Reflection, error) {
	row := q.db.QueryRow(ctx, getReflectionByID, id)
	var i Reflection
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.BudgetID,
		&i.OverallRating,
		&i.IsPrivate,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Deleted,
	)
	return i, err
}

const getReflectionQuestions = `-- name: GetReflectionQuestions :many
SELECT id, reflection_id, sequence, question_id, question_text, answer, mood, created_at, updated_at FROM reflection_questions
WHERE reflection_id = $1
ORDER BY sequence ASC
`

func (q *Queries) GetReflectionQuestions(ctx context.Context, reflectionID pgtype.UUID) ([]ReflectionQuestion, error) {
	rows, err := q.db.Query(ctx, getReflectionQuestions, reflectionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ReflectionQuestion{}
	for rows.Next() {
		var i ReflectionQuestion
		if err := rows.Scan(
			&i.ID,
			&i.ReflectionID,
			&i.Sequence,
			&i.QuestionID,
			&i.QuestionText,
			&i.Answer,
			&i.Mood,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTemplateByID = `-- name: GetTemplateByID :one
SELECT id, name, is_active, version, created_at, updated_at FROM reflection_templates
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetTemplateByID(ctx context.Context, id string) (ReflectionTemplate, error) {
	row := q.db.QueryRow(ctx, getTemplateByID, id)
	var i ReflectionTemplate
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.IsActive,
		&i.Version,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTemplateQuestions = `-- name: GetTemplateQuestions :many
SELECT id, template_id, question_id, question_text, type, is_required, has_mood_tracking, sort_order, created_at, updated_at FROM template_questions
WHERE template_id = $1
ORDER BY sort_order ASC
`

func (q *Queries) GetTemplateQuestions(ctx context.Context, templateID pgtype.UUID) ([]TemplateQuestion, error) {
	rows, err := q.db.Query(ctx, getTemplateQuestions, templateID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TemplateQuestion{}
	for rows.Next() {
		var i TemplateQuestion
		if err := rows.Scan(
			&i.ID,
			&i.TemplateID,
			&i.QuestionID,
			&i.QuestionText,
			&i.Type,
			&i.IsRequired,
			&i.HasMoodTracking,
			&i.SortOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listReflectionTemplates = `-- name: ListReflectionTemplates :many
SELECT id, name, is_active, version, created_at, updated_at FROM reflection_templates
WHERE is_active = true
ORDER BY name ASC
`

func (q *Queries) ListReflectionTemplates(ctx context.Context) ([]ReflectionTemplate, error) {
	rows, err := q.db.Query(ctx, listReflectionTemplates)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ReflectionTemplate{}
	for rows.Next() {
		var i ReflectionTemplate
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.IsActive,
			&i.Version,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserReflections = `-- name: ListUserReflections :many
SELECT id, user_id, budget_id, overall_rating, is_private, created_at, updated_at, deleted FROM reflections
WHERE user_id = $1 AND deleted = false
ORDER BY created_at DESC
`

func (q *Queries) ListUserReflections(ctx context.Context, userID pgtype.UUID) ([]Reflection, error) {
	rows, err := q.db.Query(ctx, listUserReflections, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Reflection{}
	for rows.Next() {
		var i Reflection
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.BudgetID,
			&i.OverallRating,
			&i.IsPrivate,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Deleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateReflection = `-- name: UpdateReflection :one
UPDATE reflections
SET
    overall_rating = COALESCE($2, overall_rating),
    is_private = COALESCE($3, is_private),
    updated_at = NOW()
WHERE id = $1 AND deleted = false
RETURNING id, user_id, budget_id, overall_rating, is_private, created_at, updated_at, deleted
`

type UpdateReflectionParams struct {
	ID            string      `json:"id"`
	OverallRating pgtype.Int4 `json:"overallRating"`
	IsPrivate     pgtype.Bool `json:"isPrivate"`
}

func (q *Queries) UpdateReflection(ctx context.Context, arg UpdateReflectionParams) (Reflection, error) {
	row := q.db.QueryRow(ctx, updateReflection, arg.ID, arg.OverallRating, arg.IsPrivate)
	var i Reflection
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.BudgetID,
		&i.OverallRating,
		&i.IsPrivate,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Deleted,
	)
	return i, err
}

const updateReflectionQuestion = `-- name: UpdateReflectionQuestion :one
UPDATE reflection_questions
SET
    question_text = COALESCE($2, question_text),
    answer = COALESCE($3, answer),
    mood = COALESCE($4, mood),
    updated_at = NOW()
WHERE id = $1
RETURNING id, reflection_id, sequence, question_id, question_text, answer, mood, created_at, updated_at
`

type UpdateReflectionQuestionParams struct {
	ID           string      `json:"id"`
	QuestionText pgtype.Text `json:"questionText"`
	Answer       pgtype.Text `json:"answer"`
	Mood         pgtype.Text `json:"mood"`
}

func (q *Queries) UpdateReflectionQuestion(ctx context.Context, arg UpdateReflectionQuestionParams) (ReflectionQuestion, error) {
	row := q.db.QueryRow(ctx, updateReflectionQuestion,
		arg.ID,
		arg.QuestionText,
		arg.Answer,
		arg.Mood,
	)
	var i ReflectionQuestion
	err := row.Scan(
		&i.ID,
		&i.ReflectionID,
		&i.Sequence,
		&i.QuestionID,
		&i.QuestionText,
		&i.Answer,
		&i.Mood,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateReflectionTemplate = `-- name: UpdateReflectionTemplate :one
UPDATE reflection_templates
SET
    name = COALESCE($2, name),
    is_active = COALESCE($3, is_active),
    version = COALESCE($4, version),
    updated_at = NOW()
WHERE id = $1
RETURNING id, name, is_active, version, created_at, updated_at
`

type UpdateReflectionTemplateParams struct {
	ID       string      `json:"id"`
	Name     pgtype.Text `json:"name"`
	IsActive pgtype.Bool `json:"isActive"`
	Version  pgtype.Int4 `json:"version"`
}

func (q *Queries) UpdateReflectionTemplate(ctx context.Context, arg UpdateReflectionTemplateParams) (ReflectionTemplate, error) {
	row := q.db.QueryRow(ctx, updateReflectionTemplate,
		arg.ID,
		arg.Name,
		arg.IsActive,
		arg.Version,
	)
	var i ReflectionTemplate
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.IsActive,
		&i.Version,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
